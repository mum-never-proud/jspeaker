{"version":3,"sources":["jSpeaker.js"],"names":["w","m","speechSynthesis","SpeechSynthesisUtterance","console","warn","exports","isEachPropertyMatched","obj1","obj2","keys","Object","i","length","String","toLowerCase","jSpeaker","customConfig","window","utter","config","events","currentVoice","voices","isCallbackRegistered","callbackName","wordIndex","onend","onEnd","onboundary","e","onBoundary","charIndex","elapsedTime","onvoiceschanged","getVoices","voiceSearch","onVoicesUpdate","speak","sentence","text","voice","cancel","setVoice","constructor","name","prop","default","module"],"mappings":";AAAA,SAAA,EAAA,EAAA,GAAA,IAAA,EAAA,OAAA,KAAA,GAAA,GAAA,OAAA,sBAAA,CAAA,IAAA,EAAA,OAAA,sBAAA,GAAA,IAAA,EAAA,EAAA,OAAA,SAAA,GAAA,OAAA,OAAA,yBAAA,EAAA,GAAA,cAAA,EAAA,KAAA,MAAA,EAAA,GAAA,OAAA,EAAA,SAAA,EAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,UAAA,OAAA,IAAA,CAAA,IAAA,EAAA,MAAA,UAAA,GAAA,UAAA,GAAA,GAAA,EAAA,EAAA,EAAA,OAAA,IAAA,GAAA,QAAA,SAAA,GAAA,EAAA,EAAA,EAAA,EAAA,MAAA,OAAA,0BAAA,OAAA,iBAAA,EAAA,OAAA,0BAAA,IAAA,EAAA,OAAA,IAAA,QAAA,SAAA,GAAA,OAAA,eAAA,EAAA,EAAA,OAAA,yBAAA,EAAA,MAAA,OAAA,EAAA,SAAA,EAAA,EAAA,EAAA,GAAA,OAAA,KAAA,EAAA,OAAA,eAAA,EAAA,EAAA,CAAA,MAAA,EAAA,YAAA,EAAA,cAAA,EAAA,UAAA,IAAA,EAAA,GAAA,EAAA,GAAC,SAAYA,EAAGC,GACV,IAACD,EAAEE,kBAAoBF,EAAEG,yBAM3B,OAJAC,QAAQC,KAAK,0CAEbJ,EAAEK,QAAU,MAKRC,IAAAA,EAAwB,SAACC,EAAMC,GAC/B,IAACD,IAASC,EACL,OAAA,EAKJ,IAFCC,IAAAA,EAAOC,OAAOD,KAAKF,GAEhBI,EAAI,EAAGA,EAAIF,EAAKG,OAAQD,GAAK,EAChCE,GAAAA,OAAON,EAAKE,EAAKE,KAAKG,gBAAkBD,OAAOL,EAAKC,EAAKE,KAAKG,cACzD,OAAA,EAIJ,OAAA,GAoFTd,EAAEK,QAjFOU,WAA4B,IAAA,EAAA,KAAnBC,EAAe,UAAA,OAAA,QAAA,IAAA,UAAA,GAAA,UAAA,GAAA,GACvBf,EAAoBgB,OAApBhB,gBACFiB,EAAQ,IAAIhB,yBACZiB,EAAM,EAAA,CACVC,OAAQ,GACRC,aAAc,MACXL,EAHO,CAIVM,OAAQ,KAEJC,EAAuB,SAACC,GAAiB,MAAuC,mBAAhCL,EAAOC,OAAOI,IAChEC,EAAY,EAoET,OAlEPP,EAAMQ,MAAQ,WACRH,EAAqB,UACvBJ,EAAOC,OAAOO,SAIlBT,EAAMU,WAAa,SAACC,GACdN,EAAqB,gBACvBJ,EAAOC,OAAOU,WAAW,CACvBC,UAAWF,EAAEE,UACbC,YAAaH,EAAEG,YACfP,UAAAA,IAGFA,GAAa,IAMjBxB,EAAgBgC,gBAAkB,WAChCd,EAAOG,OAASrB,EAAgBiC,YAChCf,EAAOE,aAAe,EAAKc,cAEvBZ,EAAqB,mBACvBJ,EAAOC,OAAOgB,eAAejB,EAAOG,SAInCe,KAAAA,MAAQ,SAACC,GAOL,OANPpB,EAAMqB,KAAOD,EACbpB,EAAMsB,MAAQrB,EAAOE,aACrBI,EAAY,EAEZxB,EAAgBoC,MAAMnB,GAEf,GAGJuB,KAAAA,OAAS,WAGL,OAFPxC,EAAgBwC,SAET,GAGJC,KAAAA,SAAW,SAACF,GAOR,OANHA,GAAoC,yBAA3BA,EAAMG,YAAYC,KAC7BzB,EAAOE,aAAemB,EAEtBrB,EAAOE,aAAe,EAAKc,YAAYK,IAAUrB,EAAOE,aAGnD,GAGJc,KAAAA,YAAc,SAACU,GACb,IAAA,IAAIlC,EAAI,EAAGA,EAAIQ,EAAOG,OAAOV,OAAQD,GAAK,EACxC,IAACkC,GAAQ1B,EAAOG,OAAOX,GAAGmC,SAC1BxC,EAAsBuC,EAAM1B,EAAOG,OAAOX,IACtCQ,OAAAA,EAAOG,OAAOX,GAIlB,OAAA,MAGF,MAxGV,CA4GCM,OAAQ8B","file":"jSpeaker.min.js","sourceRoot":"../src","sourcesContent":["(function $j(w, m) {\n  if (!w.speechSynthesis || !w.SpeechSynthesisUtterance) {\n    // eslint-disable-next-line no-console\n    console.warn('speech synthesis is not available');\n\n    m.exports = null;\n\n    return;\n  }\n\n  const isEachPropertyMatched = (obj1, obj2) => {\n    if (!obj1 || !obj2) {\n      return false;\n    }\n\n    const keys = Object.keys(obj1);\n\n    for (let i = 0; i < keys.length; i += 1) {\n      if (String(obj1[keys[i]]).toLowerCase() !== String(obj2[keys[i]]).toLowerCase()) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  function jSpeaker(customConfig = {}) {\n    const { speechSynthesis } = window;\n    const utter = new SpeechSynthesisUtterance();\n    const config = {\n      events: {},\n      currentVoice: null,\n      ...customConfig,\n      voices: [],\n    };\n    const isCallbackRegistered = (callbackName) => typeof config.events[callbackName] === 'function';\n    let wordIndex = 0;\n\n    utter.onend = () => {\n      if (isCallbackRegistered('onEnd')) {\n        config.events.onEnd();\n      }\n    };\n\n    utter.onboundary = (e) => {\n      if (isCallbackRegistered('onBoundary')) {\n        config.events.onBoundary({\n          charIndex: e.charIndex,\n          elapsedTime: e.elapsedTime,\n          wordIndex,\n        });\n\n        wordIndex += 1;\n      }\n    };\n\n    // to make sure safari doesn't screws up\n\n    speechSynthesis.onvoiceschanged = () => {\n      config.voices = speechSynthesis.getVoices();\n      config.currentVoice = this.voiceSearch();\n\n      if (isCallbackRegistered('onVoicesUpdate')) {\n        config.events.onVoicesUpdate(config.voices);\n      }\n    };\n\n    this.speak = (sentence) => {\n      utter.text = sentence;\n      utter.voice = config.currentVoice;\n      wordIndex = 0;\n\n      speechSynthesis.speak(utter);\n\n      return this;\n    };\n\n    this.cancel = () => {\n      speechSynthesis.cancel();\n\n      return this;\n    };\n\n    this.setVoice = (voice) => {\n      if (voice && voice.constructor.name === 'SpeechSynthesisVoice') {\n        config.currentVoice = voice;\n      } else {\n        config.currentVoice = this.voiceSearch(voice) || config.currentVoice;\n      }\n\n      return this;\n    };\n\n    this.voiceSearch = (prop) => {\n      for (let i = 0; i < config.voices.length; i += 1) {\n        if ((!prop && config.voices[i].default)\n          || isEachPropertyMatched(prop, config.voices[i])) {\n          return config.voices[i];\n        }\n      }\n\n      return null;\n    };\n\n    return this;\n  }\n\n  m.exports = jSpeaker;\n}(window, module));\n"]}